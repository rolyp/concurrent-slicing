open import ConcurrentSlicingCommon
open import Transition.Concur.Cofinal.Lattice.Common

import Relation.Binary.EqReasoning as EqReasoning
import Ren as ᴿ

module Transition.Concur.Cofinal.Lattice.case.sync-sync
   {Γ} {x y u z : Name Γ} {P₀ Q₀ R₀ R′₀ S₀ S′₀} {E : P₀ —[ x • ᵇ - _ ]→ R₀} {E′ : P₀ —[ u • ᵇ - _ ]→ R′₀}
   {F : Q₀ —[ • x 〈 y 〉 ᶜ - _ ]→ S₀} {F′ : Q₀ —[ • u 〈 z 〉 ᶜ - _ ]→ S′₀} (𝐸 : E ⌣₁[ ᵇ∇ᵇ ] E′) (𝐹 : F ⌣₁[ ᶜ∇ᶜ ] F′)
   (P : ↓ P₀) (Q : ↓ Q₀)
   (IH₁ : braiding (ᵇ∇ᵇ {a = x •} {u •}) {0} (γ₁ 𝐸) (tgt (E′/E (⊖₁ 𝐸)) (tgt E P)) ≡ tgt (E/E′ (⊖₁ 𝐸)) (tgt E′ P))
   (IH₂ : braiding (ᶜ∇ᶜ {a = • x 〈 y 〉} {• u 〈 z 〉}) {0} (γ₁ 𝐹) (tgt (E′/E (⊖₁ 𝐹)) (tgt F Q)) ≡ tgt (E/E′ (⊖₁ 𝐹)) (tgt F′ Q))
   (let
      P′₀ = tgt₁ (⊖₁ 𝐸); P″₀ = tgt₂(⊖₁ 𝐸)
      open EqReasoning (setoid _)
      α =
         begin
            (ᴿ.pop z *) ((ᴿ.suc (ᴿ.pop y) *) P′₀)
         ≡⟨ sym (pop-pop-swap y z _) ⟩
            (ᴿ.pop y *) ((ᴿ.suc (ᴿ.pop z) *) ((ᴿ.swap *) P′₀))
         ≡⟨ cong (ᴿ.pop y *) (cong (ᴿ.suc (ᴿ.pop z) *) (γ₁ 𝐸)) ⟩
            (ᴿ.pop y *) ((ᴿ.suc (ᴿ.pop z) *) P″₀)
         ∎)
   where

   postulate
    case :
      braiding (ᶜ∇ᶜ {a = τ} {τ}) {0} (cong₂ _│_ α (γ₁ 𝐹))
      (tgt (E′/E (⊖₁ (𝐸 │• 𝐹))) (tgt (E │• F) [ P │ Q ]))
      ≡
      tgt (E/E′ (⊖₁ (𝐸 │• 𝐹))) (tgt (E′ │• F′) [ P │ Q ])
